# מדינת ישראל משרד החינוך
## מנהל טכנולוגיה, אגף טכנולוגיה. מזכירות פדגוגית, אגף מדעים 
## הפיקוח על הוראת מדעי המחשב, הנדסת תוכנה וסייבר – יסודי, חט"ב, חט"ע

# תיק פרויקט בחלופה הגנת סייבר ומערכות הפעלה
## במסגרת לימודי ההתמחות בהנדסת תוכנה 883589

<div style="text-align: center;">
    <img src="/logo.svg" alt="ROIM Logo" width="200" height="200"/>
</div>

**שם בית הספר**: תיכון עירוני ה'

**שם העבודה**: ROIM - פלטפורמת סטרימינג מאובטחת

**שם התלמיד**: ישראל ישראלי

**ת.ז. התלמיד**: 123456789

**שם המנחה**: דר' נועם כהן

**שם החלופה**: הגנת סייבר ומערכות הפעלה

**תאריך ההגשה**: 06.05.2025

## תוכן עניינים
1. [מבוא](#מבוא)
2. [מבנה / ארכיטקטורה של הפרויקט](#מבנה--ארכיטקטורה-של-הפרויקט)
3. [מימוש הפרויקט](#מימוש-הפרויקט)
4. [מדריך למשתמש](#מדריך-למשתמש)
5. [סיכום אישי / רפלקציה](#סיכום-אישי--רפלקציה)
6. [ביבליוגרפיה](#ביבליוגרפיה)
7. [נספחים](#נספחים)

# מבוא

## ייזום
### תיאור ראשוני של המערכת

ROIM היא פלטפורמת סטרימינג מקוונת המיועדת לחובבי משחקים ויוצרי תוכן דיגיטלי. המערכת מאפשרת ליוצרים לשדר תוכן בזמן אמת ולצופים לצפות בשידורים, להגיב בצ'אט ולעקוב אחרי יוצרים מועדפים. המערכת תומכת בהרשמה, כניסה, ניהול פרופיל, שידור חי, צפייה בשידורים, צ'אט בזמן אמת, ומערכת עוקבים. הפרויקט המוגמר אמור לספק חוויית משתמש דומה לפלטפורמות סטרימינג מובילות כמו Twitch, אך עם דגש על אבטחה ופרטיות.

בחרתי בפרויקט זה מכיוון שאני מתעניין בפיתוח מערכות web בזמן אמת, טכנולוגיות סטרימינג, וניהול אבטחת סייבר במערכות מורכבות. האתגרים העיקריים שאני צופה בפרויקט הם יישום מערכת הסטרימינג בזמן אמת, ניהול עומסים, אבטחת הפלטפורמה מפני התקפות סייבר שונות, והבטחת פרטיות המשתמשים.

### הגדרת הלקוח

המערכת מיועדת לשני סוגי משתמשים עיקריים:
- **סטרימרים (יוצרי תוכן)**: משתמשים המעוניינים לשדר תוכן חי כגון משחקי וידאו, שיחות או כל תוכן אחר.
- **צופים**: משתמשים המעוניינים לצפות בתוכן המשודר, להשתתף בצ'אט ולעקוב אחרי סטרימרים.

### הגדרת יעדים/מטרות

המטרות המרכזיות של המערכת:
1. יצירת פלטפורמה נגישה ואינטואיטיבית לשידור וצפייה בתוכן בזמן אמת
2. אבטחת המידע והתקשורת בין המשתמשים והשרת
3. מתן כלים לסטרימרים לניהול השידור והקהילה שלהם
4. יצירת חווית משתמש חלקה ומהירה לצופים
5. תמיכה בפעולות חברתיות כמו עקיבה אחר יוצרים, צ'אט בזמן אמת וחסימת משתמשים
6. יישום מנגנוני הגנה מתקדמים נגד התקפות סייבר נפוצות

### בעיות תועלות וחסכונות

**הבעיות שהמערכת מנסה לפתור:**
- הצורך בפלטפורמת סטרימינג מאובטחת עבור יוצרי תוכן
- ניהול קהילה ותקשורת בזמן אמת
- אבטחת זהות המשתמשים ומניעת התחזות

**התועלות הצפויות:**
- מערכת סטרימינג אמינה ובטוחה
- ממשק משתמש אינטואיטיבי
- אפשרויות לבניית קהילה סביב תוכן
- רמה גבוהה של אבטחת מידע

**חסכונות:**
- חיסכון בזמן ומשאבים של יוצרים בניהול תוכן ואבטחה
- מניעת נזקים פוטנציאליים הקשורים לפריצות אבטחה
- שיפור יעילות בניהול משתמשים וקהילות

### סקירת פתרונות קיימים

השוואה עם פלטפורמות קיימות:
- **Twitch**: פלטפורמת סטרימינג מובילה עם תכונות רבות, אך חסרה במספר היבטי אבטחה.
- **YouTube Live**: פלטפורמה נוחה לשימוש, אך פחות ממוקדת בקהילות גיימינג.
- **Facebook Gaming**: משולבת בפלטפורמה חברתית רחבה, אך חסרה בכלים ייחודיים לסטרימרים.

הפרויקט שלנו (ROIM) מתמקד בשילוב תכונות מובילות מהפלטפורמות הקיימות עם מנגנוני אבטחה מתקדמים ומערכת ניהול קהילה משופרת.

### סקירת טכנולוגית הפרויקט

הפרויקט משתמש בטכנולוגיות חדשניות:
- **Next.js**: פריימוורק React מתקדם לבניית אפליקציות web מהירות ומאובטחות
- **TypeScript**: שפת תכנות המספקת בטיחות טיפוסים ושיפור יכולות התחזוקה
- **Prisma ORM**: מערכת ניהול מסד נתונים מודרנית המאפשרת עבודה בטוחה יותר עם הנתונים
- **MySQL**: מסד נתונים יציב ומאובטח
- **LiveKit**: ספריית סטרימינג בזמן אמת המאפשרת העברת וידאו ואודיו באיכות גבוהה
- **NextAuth**: מערכת אימות מאובטחת לניהול משתמשים והרשאות

**סייגים בהגדרת המערכת:**
- המערכת כרגע מוגבלת לשידור וידאו ללא יכולות שיתוף מסך מתקדמות
- נדרש ציוד מיוחד כגון מצלמה, מיקרופון וחיבור אינטרנט מהיר לשידור איכותי
- מגבלות רוחב פס עלולות להשפיע על איכות השידור

### תיחום הפרויקט

**תחומים בהם הפרויקט עוסק בדגש על רשתות ומערכות הפעלה:**
- אבטחת רשתות וניהול תקשורת בזמן אמת
- מערכת אימות והרשאות מתקדמת
- הצפנת מידע ותקשורת
- ניהול מערכת הפעלה לשרת סטרימינג
- הגנה מפני התקפות סייבר נפוצות
- ניהול סשנים וטוקנים מאובטחים

**תחומים בהם המערכת לא מטפלת:**
- פיתוח תוכן או משחקים
- אחסון קבצי וידאו (רק תמיכה בשידור חי)
- תשלומים ומנויים (בשלב ראשון)
- אינטגרציה עם פלטפורמות חברתיות חיצוניות

## פירוט תיאור המערכת (אפיון)

### תיאור מפורט של המערכת

ROIM היא פלטפורמת סטרימינג מאובטחת המאפשרת למשתמשים לשדר תוכן וידאו חי ולצפות בו, עם מערכת צ'אט בזמן אמת וכלי ניהול קהילה. המערכת אמורה לאפשר:

- **אימות משתמשים** באמצעות מערכת רישום וכניסה מאובטחת, כולל תמיכה באימות דו-שלבי ואפשרויות כניסה באמצעות חשבון Google.
- **שידור וידאו חי** בטכנולוגיית WebRTC באמצעות LiveKit, עם תמיכה בפרוטוקולים מאובטחים.
- **מערכת צ'אט בזמן אמת** עם אפשרויות מודרציה, השהיית הודעות, והגבלת צ'אט לעוקבים בלבד.
- **ניהול קהילה** באמצעות מערכת עוקבים וחסימת משתמשים.
- **יכולות חיפוש ודף בית** המציגים שידורים פעילים ומומלצים.
- **לוח מחוונים למשדרים** לניהול הגדרות שידור, אופן הצגת הערוץ, ופיקוח על קהילת המשתמשים.
- **מערכת אבטחה** המגנה מפני התקפות נפוצות כמו SQL Injection, XSS, CSRF, ועוד.

### פירוט היכולות לכל סוג משתמש במערכת

**משתמשים לא מחוברים (אורחים):**
- צפייה בשידורים חיים
- חיפוש ערוצים
- הרשמה/כניסה למערכת

**משתמשים רגילים (צופים):**
- כל היכולות של אורחים
- יצירת פרופיל אישי
- מעקב אחרי ערוצים
- השתתפות בצ'אטים
- חסימת משתמשים אחרים

**סטרימרים (יוצרי תוכן):**
- כל היכולות של משתמשים רגילים
- שידור תוכן חי
- ניהול ערוץ (כותרת, תמונה ממוזערת, תיאור)
- הגדרות צ'אט (מצב מושהה, הגבלה לעוקבים)
- ניהול קהילה (צפייה וניהול משתמשים חסומים)
- הגדרות שידור (מפתחות שידור, כתובות שרת)

### פירוט הבדיקות

**בדיקות אבטחה (קופסא שחורה):**
1. **בדיקת אימות משתמשים**: בדיקת עמידות מערכת ההרשמה והכניסה בפני התקפות, אימות כתובות אימייל וחוזק סיסמאות.
   - תהליך: ניסיונות כניסה חוזרים, בדיקת אימות אימייל, בדיקת מדיניות סיסמאות
   
2. **בדיקת הרשאות**: בדיקה שמשתמשים יכולים לגשת רק למשאבים המותרים להם.
   - תהליך: גישה לדפים מוגנים ללא הרשאות מתאימות, ניסיון שינוי נתונים של משתמשים אחרים

3. **בדיקת הגנה מפני SQL Injection**: בדיקת שדות קלט לעמידות בפני התקפות הזרקת קוד SQL.
   - תהליך: הזנת קוד SQL זדוני בשדות טופס, בדיקת תגובת המערכת

4. **בדיקת הצפנת מידע**: בדיקת הצפנת סיסמאות, טוקנים ותקשורת.
   - תהליך: ניתוח תהליך האימות, בדיקת שימוש ב-HTTPS, מעקב אחר נתונים רגישים

5. **בדיקת מערכת סטרימינג**: בדיקת אבטחת ערוץ השידור וההרשאות לצפייה.
   - תהליך: ניסיון לגשת לשידורים פרטיים, בדיקת תקינות מפתחות שידור

### תכנון וניהול לו"ז

| שלב | תיאור | זמן מתוכנן | זמן בפועל |
|-----|-------|------------|-----------|
| איסוף דרישות וייזום | הגדרת מטרות ודרישות המערכת | 2 שבועות | 3 שבועות |
| תכנון ארכיטקטורה | תכנון מבנה המערכת, בחירת טכנולוגיות | 3 שבועות | 3 שבועות |
| פיתוח מערכת האימות | הקמת מערכת הרשמה, כניסה, ואימות אימייל | 4 שבועות | 5 שבועות |
| פיתוח ממשק משתמש בסיסי | יצירת דפי בית, פרופיל, וניווט | 3 שבועות | 4 שבועות |
| פיתוח מערכת סטרימינג | אינטגרציה עם LiveKit, הגדרת שרתי שידור | 6 שבועות | 8 שבועות |
| פיתוח צ'אט ואינטראקציה | מערכת צ'אט בזמן אמת, עוקבים וחסימות | 5 שבועות | 6 שבועות |
| יישום אמצעי אבטחה | הגנה מפני SQL Injection, XSS, CSRF | 4 שבועות | 5 שבועות |
| בדיקות | בדיקות אבטחה, ביצועים ושימושיות | 3 שבועות | 4 שבועות |
| תיקון באגים ושיפורים | מענה לבעיות שהתגלו בבדיקות | 3 שבועות | 4 שבועות |
| תיעוד והערכות לסיום | כתיבת תיעוד למשתמש ולמפתחים | 2 שבועות | 3 שבועות |

### ניהול הסיכונים בפרויקט והדרכים להתמודדות איתם

| סיכון | דרך התמודדות מתוכננת | התמודדות בפועל |
|-------|------------------------|----------------|
| פריצות אבטחה | יישום מנגנוני אבטחה מתקדמים, תיקוף קלט, הצפנת מידע | יישום NextAuth עם טיפול בהרשאות, תיקוף עם Zod, הצפנת סיסמאות עם bcrypt |
| ביצועים לקויים בעומס | מערכת לניהול עומסים, שימוש בטכנולוגיות זמן אמת יעילות | שימוש ב-LiveKit לניהול יעיל של חיבורי סטרימינג, יישום React Server Components לביצועים משופרים |
| בעיות תאימות דפדפנים | בדיקות קפדניות במגוון דפדפנים ומכשירים | יישום CSS ו-JavaScript תואמי קרוס-בראוזר, שימוש ב-polyfills במקרה הצורך |
| מורכבות טכנית של מערכת הסטרימינג | שימוש בספריות מוכחות ובדוקות | שימוש ב-LiveKit כפתרון מוכח לסטרימינג, הגדרת תצורה מפורטת ומתועדת |
| זמינות נמוכה של השירות | תכנון תשתית עמידה לכשלים | שימוש בהמתנה סבילה ומנגנוני ניסיון חוזר, טיפול שגיאות מקיף |

## תיאור תחום הידע - הרחבה על אבטחת סייבר ומערכות הפעלה

### פירוט היכולות בצד שרת

1. **מערכת אימות משתמשים**:
   - שימוש ב-NextAuth לניהול מאובטח של הרשאות ומשתמשים
   - תמיכה באימות באמצעות אימייל וסיסמה או חשבון Google
   - אימות דו-שלבי באמצעות אימות אימייל
   - ניהול טוקנים ועדכונם

2. **אבטחת מסד נתונים**:
   - שימוש ב-Prisma ORM להגנה מפני SQL Injection
   - מבנה מסד נתונים מאובטח עם מודל הרשאות והפרדת משאבים
   - ניהול טרנזקציות ושמירה על עקביות הנתונים

3. **ניהול שרת סטרימינג**:
   - הגנה על ערוצי שידור באמצעות מפתחות ייחודיים
   - תמיכה בפרוטוקולי סטרימינג מאובטחים (RTMP, WHIP)
   - ניטור סטטוס שידורים וניהול אירועי webhook

4. **אבטחת API**:
   - בקרת גישה מבוססת תפקידים והרשאות
   - הגנה מפני CSRF באמצעות טוקנים
   - תיקוף קלט באמצעות ספריית Zod
   - מניעת חשיפת מידע רגיש

5. **הצפנה ופרטיות**:
   - הצפנת סיסמאות עם bcrypt
   - הצפנת תקשורת באמצעות HTTPS
   - ניהול מאובטח של סשנים וטוקנים

### פירוט היכולות בצד לקוח

1. **ממשק משתמש מאובטח**:
   - הגנה מפני XSS באמצעות טיפול נכון בקלט משתמש
   - ניהול מצבי אימות והרשאות בממשק
   - תצוגת התראות אבטחה ואימות

2. **ניהול סטרימינג בצד לקוח**:
   - יכולות קבלת וידאו מוצפן בזמן אמת
   - ניהול חיבור מאובטח לשרת הסטרימינג
   - התאוששות אוטומטית מבעיות תקשורת

3. **צ'אט בזמן אמת**:
   - סינון תוכן וניהול הודעות
   - אפשרויות פרטיות ומודרציה
   - הגנה מפני הצפות וספאם

4. **ניהול קהילה**:
   - מערכת עוקבים ומעקב
   - חסימת משתמשים ודיווח על הפרות
   - ניהול הרשאות צפייה וצ'אט

### פירוט יכולת לדוגמה: הרשמה למערכת

**שם היכולת**: הרשמה למערכת

**מהות**: רישום משתמש חדש במערכת – קליטת פרטים אישיים נדרשים, אימות אימייל, והגנה על המידע

**אוסף יכולות נדרשות**:
- ממשק משתמש – טופס הרשמה
- קליטת נתונים (שם משתמש, אימייל, סיסמה)
- בדיקת תקינות הקלט (אימות פורמט אימייל, חוזק סיסמה)
- הצפנת הסיסמה עם bcrypt
- שליחה לשרת המרכזי
- בדיקת ייחודיות המשתמש במסד הנתונים
- יצירת טוקן אימות אימייל
- שליחת אימייל אימות
- שמירת המשתמש במסד הנתונים
- הצגת הודעת הצלחה למשתמש

**אובייקטים נחוצים**: ממשק משתמש, מנגנון הצפנה/פענוח, תקשורת, בסיס נתונים, מנגנון שליחת אימייל

# מבנה / ארכיטקטורה של הפרויקט

## תיאור הארכיטקטורה של המערכת המוצעת

### תיאור החומרה

המערכת מתוכננת לפעול בארכיטקטורת לקוח-שרת, כאשר הלקוח מריץ את האפליקציה בדפדפן אינטרנט והשרת מנהל את הלוגיקה העסקית, הגישה למסד הנתונים, ושירותי הסטרימינג. 

רכיבי החומרה הנדרשים:
- **שרת אפליקציה**: שרת לאירוח אפליקציית Next.js
- **שרת מסד נתונים**: שרת MySQL לאחסון נתוני המערכת
- **שרת סטרימינג**: שרת LiveKit לניהול שידורי הווידאו והצ'אט בזמן אמת
- **שרת תקשורת**: שרת לניהול תקשורת בזמן אמת (WebSockets)

ההקשרים בין הרכיבים:
- שרת האפליקציה מתקשר עם שרת מסד הנתונים לאחסון ואחזור מידע
- שרת האפליקציה מתקשר עם שרת הסטרימינג לניהול חיבורי וידאו
- שרת האפליקציה מתקשר עם שרת התקשורת לניהול צ'אט והודעות בזמן אמת
- הלקוח (דפדפן) מתקשר עם שרת האפליקציה לקבלת תוכן UI ולוגיקה
- הלקוח מתקשר ישירות עם שרת הסטרימינג לקבלת שידורי וידאו בזמן אמת

<div style="text-align: center;">
    <img src="system_architecture.png" alt="תרשים ארכיטקטורת מערכת" width="600"/>
</div>

## תיאור הטכנולוגיה הרלוונטית

### שפת תכנות
- **TypeScript/JavaScript**: שפות מודרניות המשמשות לפיתוח הן בצד הלקוח והן בצד השרת
- **Node.js**: סביבת ריצה לקוד JavaScript בצד השרת

### מערכת הפעלה
- **Linux**: שרתי האפליקציה והסטרימינג פועלים על מערכת ההפעלה Linux, המספקת יציבות, אבטחה וביצועים מעולים לשרתים
- **צד לקוח**: תמיכה בכל מערכות ההפעלה עם דפדפן מודרני (Windows, macOS, Linux, Android, iOS)

### תקשורת
- **HTTP/HTTPS**: פרוטוקולי תקשורת עיקריים לפניות ותשובות REST API
- **WebSockets**: לתקשורת דו-כיוונית בזמן אמת עבור צ'אט והתראות
- **WebRTC**: לשידורי וידאו בזמן אמת באיכות גבוהה
- **RTMP/WHIP**: פרוטוקולי סטרימינג לשידור וידאו

### תחומי עניין
- **אבטחת סייבר**: יישום פרקטיקות אבטחה מתקדמות להגנה על המערכת ומשתמשיה
- **סטרימינג בזמן אמת**: טכנולוגיות לשידור וקבלת וידאו באיכות גבוהה
- **ניהול משתמשים**: מערכות אימות, הרשאות וניהול זהויות

## תיאור זרימת המידע במערכת

### זרימת מידע בתהליך הרשמה וכניסה
1. משתמש מזין פרטי הרשמה בטופס
2. פרטים נשלחים לשרת (API route)
3. השרת מבצע תיקוף נתונים, הצפנת סיסמה ויצירת משתמש במסד נתונים
4. השרת שולח אימייל אימות למשתמש
5. המשתמש מאשר באמצעות קישור באימייל
6. בתהליך כניסה, השרת מאמת פרטים ומנפיק טוקן כניסה
7. הדפדפן מאחסן את הטוקן ומשתמש בו לבקשות עתידיות

### זרימת מידע בתהליך סטרימינג
1. הסטרימר מקבל מפתחות סטרימינג מהמערכת
2. הסטרימר משדר באמצעות תוכנת שידור (כגון OBS) לשרת הסטרימינג
3. שרת הסטרימינג מעבד את הווידאו ומכין אותו להפצה
4. צופים מתחברים לערוץ השידור
5. שרת הסטרימינג מעביר את הווידאו לדפדפני הצופים
6. בזמן הצפייה, הודעות צ'אט מועברות בין הצופים והסטרימר

<div style="text-align: center;">
    <img src="dataflow_diagram.png" alt="תרשים זרימת מידע" width="600"/>
</div>

## תיאור האלגוריתמים מרכזיים בפרויקט

### ניסוח וניתוח הבעיה האלגוריתמית: אימות משתמשים
בעיית אימות המשתמשים מורכבת מהצורך לזהות משתמשים באופן מאובטח, תוך שמירה על פרטיותם והגנה מפני התקפות שונות.

### תיאור אלגוריתמים קיימים לפתרון הבעיה
1. **אימות מבוסס סיסמה**: שיטה בסיסית המשתמשת בשם משתמש וסיסמה
2. **אימות דו-שלבי**: הוספת שכבת אבטחה נוספת באמצעות קוד או קישור חד-פעמי
3. **אימות OAuth**: שימוש בשירותי צד שלישי (כגון Google) לאימות
4. **אימות JWT**: שימוש בטוקנים מוצפנים לניהול סשנים ואימות

### סקירת הפתרון הנבחר
בפרויקט זה בחרנו ליישם שילוב של מספר שיטות אימות:
- אימות מבוסס סיסמה עם הצפנת סיסמאות חזקה (bcrypt)
- אימות אימייל להבטחת אמינות המשתמש
- תמיכה באימות OAuth עם Google
- ניהול סשנים מאובטח באמצעות JWT וNextAuth

הבחירה בגישה משולבת זו מאפשרת גמישות למשתמשים לצד רמת אבטחה גבוהה. האלגוריתמים האלטרנטיביים, כגון אימות ביומטרי או אימות מבוסס חומרה, לא נבחרו בשל מורכבות היישום והצורך בתמיכה רחבה בדפדפנים.

## תיאור סביבת הפיתוח

### פרוט כלי הפיתוח הדרושים לפיתוח
- **Visual Studio Code**: סביבת פיתוח
- **Node.js**: סביבת ריצה לפיתוח השרת
- **npm**: מנהל חבילות לניהול תלויות
- **Git**: מערכת ניהול גרסאות
- **GitHub**: אחסון קוד ושיתוף פעולה

### פרוט הסביבה והכלים הנדרשים לבדיקות
- **Jest**: מסגרת בדיקות ליחידות קוד
- **Cypress**: כלי לבדיקות End-to-End
- **OWASP ZAP**: כלי לבדיקות אבטחה
- **Lighthouse**: בדיקות ביצועים וחוויית משתמש
- **Postman**: בדיקות API

## תיאור פרוטוקול התקשורת

### תיאור מילולי של פרוטוקול התקשורת
המערכת משתמשת במספר פרוטוקולי תקשורת:
- **HTTP/HTTPS**: לתקשורת RESTful בין הלקוח והשרת
- **WebSockets**: לתקשורת דו-כיוונית בזמן אמת עבור הצ'אט
- **RTMP/WHIP**: לשידור וידאו מהסטרימר לשרת
- **WebRTC**: להעברת הווידאו מהשרת לצופים

### פירוט כלל ההודעות הזורמות במערכת

**שם ההודעה**: בקשת אימות משתמש  
**נשלחת מ**: לקוח (דפדפן)  
**אל**: שרת (API)  
**מבנה השדות בהודעה**: `{ name: string, password: string }`

**שם ההודעה**: הודעת צ'אט  
**נשלחת מ**: לקוח (דפדפן משתמש)  
**אל**: שרת (LiveKit)  
**מבנה השדות בהודעה**: `{ from: { name: string }, message: string, timestamp: number }`

**שם ההודעה**: התחלת שידור  
**נשלחת מ**: שרת סטרימינג  
**אל**: שרת אפליקציה  
**מבנה השדות בהודעה**: `{ ingressId: string, event: "ingress_started" }`

## תיאור מסכי המערכת

### דף בית (Home)
**תפקיד המסך**: הצגת שידורים פעילים ומומלצים  
**תיאור המסך**: מציג גריד של שידורים פעילים עם תמונות ממוזערות, שם הסטרימר, כותרת השידור וסטטוס השידור (חי/לא פעיל)  
**תמונת מסך**: [דף בית]

### דף שידור (Stream)
**תפקיד המסך**: צפייה בשידור חי ואינטראקציה עם הצ'אט  
**תיאור המסך**: מציג וידאו ראשי של השידור, מידע על הסטרימר, חלונית צ'אט, כפתורי עקיבה/חסימה  
**תמונת מסך**: [דף שידור]

### לוח מחוונים למשדר (Dashboard)
**תפקיד המסך**: ניהול הגדרות שידור וערוץ  
**תיאור המסך**: מאפשר שליטה בהגדרות שידור, ניהול פרטי הערוץ, צפייה בסטטיסטיקות, וניהול הקהילה  
**תמונת מסך**: [לוח מחוונים]

### מסך ניהול מפתחות שידור (Stream Keys)
**תפקיד המסך**: הצגת מפתחות וכתובות שידור  
**תיאור המסך**: מציג את כתובת השרת ומפתח השידור, מאפשר יצירת מפתח חדש  
**תמונת מסך**: [ניהול מפתחות]

<div style="text-align: center;">
    <img src="screen_flow_diagram.png" alt="תרשים מסכים" width="600"/>
</div>

## תיאור מבני הנתונים

### פירוט מבני הנתונים
הפרויקט משתמש במספר מבני נתונים מרכזיים:

1. **מסד נתונים MySQL**: מאחסן את כל נתוני המערכת במבנה יחסי
2. **מבנה JSON**: משמש לתקשורת API ולאחסון הגדרות
3. **מבנה JWT**: מאחסן טוקנים מוצפנים לאימות משתמשים

### פירוט מאגרי המידע של המערכת

**מסד נתונים**: Main Database

**טבלאות**:
- **User**: מידע על משתמשים
  - id (PK, UUID): מזהה ייחודי
  - name (String, Unique): שם משתמש
  - email (String, Unique): אימייל
  - password (String, Nullable): סיסמה מוצפנת
  - image (String): תמונת פרופיל
  - bio (Text): ביוגרפיה
  - emailVerified (DateTime): תאריך אימות אימייל
  - createdAt (DateTime): תאריך יצירה
  - updatedAt (DateTime): תאריך עדכון

- **Stream**: מידע על ערוצי השידור
  - id (PK, UUID): מזהה ייחודי
  - userId (FK): מזהה המשתמש
  - name (Text): שם השידור
  - thumbnailUrl (Text): כתובת תמונה ממוזערת
  - ingressId (String): מזהה כניסה לשרת סטרימינג
  - serverUrl (Text): כתובת שרת הסטרימינג
  - streamKey (Text): מפתח שידור מוצפן
  - isLive (Boolean): סטטוס שידור חי
  - isChatEnabled (Boolean): האם הצ'אט פעיל
  - isChatDelayed (Boolean): האם הצ'אט מושהה
  - isChatFollowersOnly (Boolean): האם הצ'אט מוגבל לעוקבים
  - createdAt (DateTime): תאריך יצירה
  - updatedAt (DateTime): תאריך עדכון

- **Follow**: מידע על קשרי עקיבה בין משתמשים
  - id (PK, UUID): מזהה ייחודי
  - followerId (FK): מזהה העוקב
  - followingId (FK): מזהה המשתמש שעוקבים אחריו
  - createdAt (DateTime): תאריך יצירה
  - updatedAt (DateTime): תאריך עדכון

- **Block**: מידע על חסימות משתמשים
  - id (PK, UUID): מזהה ייחודי
  - blockerId (FK): מזהה החוסם
  - blockedId (FK): מזהה המשתמש החסום
  - createdAt (DateTime): תאריך יצירה
  - updatedAt (DateTime): תאריך עדכון

דוגמה לערכים אפשריים:
- User.id: "550e8400-e29b-41d4-a716-446655440000"
- User.name: "streamer123"
- User.email: "streamer@example.com"
- Stream.isLive: true

## סקירת חולשות והאיומים

### סקירת האיומים שיתכנו למערכת והפתרונות

#### שכבת האפליקציה

**עבודה עם בסיס נתונים - SQL Injection**
- **איום**: הזרקת קוד SQL זדוני לשאילתות מסד הנתונים
- **פתרון**: שימוש ב-Prisma ORM המבצע תיקוף פרמטרים והכנת שאילתות באופן אוטומטי, בדיקות תקינות קלט בשכבת הבקרה

**עבודה עם אתרי Web - XSS**
- **איום**: הזרקת סקריפטים זדוניים לדפי האתר
- **פתרון**: סניטציה של קלטים משתמש, שימוש ב-Content Security Policy, הגדרת הדר X-XSS-Protection

**תהליך ה-Login - אימות ווידוא**
- **איום**: התקפות כוח גס, התחזות, גניבת סשן
- **פתרון**: שימוש ב-NextAuth, הגבלת ניסיונות כניסה, סיסמאות חזקות, אימות דו-שלבי, טוקנים מאובטחים

**MITM (Man In The Middle) - הצפנה**
- **איום**: יירוט תקשורת בין המשתמש לשרת
- **פתרון**: שימוש ב-HTTPS, הצפנת נתונים רגישים, שימוש בהדרי אבטחה נכונים

**DOS/DDOS - מניעת שירות**
- **איום**: התקפות להשבתת השירות
- **פתרון**: שימוש בשירותי ענן עם הגנות DDoS, הגבלת קצב בקשות, ניטור תעבורה חריגה

**העלאת קבצים - אבטחת תוכן**
- **איום**: העלאת קבצים זדוניים או חריגים
- **פתרון**: תיקוף סוג הקובץ וגודלו, סריקת קבצים, שימוש בפונקציות hash לאימות, שירות UploadThing לאחסון מאובטח

#### שכבת התעבורה

**פרוטוקול TCP - לחיצת יד משולשת**
- **איום**: התקפות לניצול חולשות בפרוטוקול TCP
- **פתרון**: הגדרת פרמטרי TCP נכונים, מעקב אחר מצב חיבורים, שימוש בטכנולוגיות load balancing

**הצפנה**
- **איום**: יירוט וקריאת מידע רגיש
- **פתרון**: שימוש בפרוטוקולי TLS מעודכנים, הצפנת נתונים רגישים end-to-end, שימוש נכון במפתחות הצפנה

#### הפעלת המערכת

**חולשות מערכת ההפעלה**
- **איום**: ניצול חולשות במערכת ההפעלה או בספריות תלויות
- **פתרון**: עדכון שוטף של מערכת ההפעלה וחבילות, שימוש בהקשחות נדרשות, ניהול הרשאות מתאים

# מימוש הפרויקט

## חלק א - סקירת המודולים / מחלקות

### מודולים/מחלקות מיובאים

1. **NextAuth** 
   - מודול לניהול אימות משתמשים ואבטחה
   - מיועד לטיפול במערכת ההרשמה, כניסה, ואימות משתמשים בצורה מאובטחת

2. **PrismaClient**
   - מודול לניהול הגישה למסד הנתונים
   - מיועד לביצוע פעולות CRUD במסד הנתונים תוך מניעת SQL Injection

3. **LiveKit**
   - מודול לניהול שידורי וידאו בזמן אמת
   - מיועד לניהול חיבורי סטרימינג, הפצת וידאו, וניהול צ'אט בזמן אמת

4. **bcrypt**
   - מודול להצפנת סיסמאות
   - מיועד לשמירה מאובטחת של סיסמאות משתמשים

5. **Zod**
   - מודול לתיקוף סכמות
   - מיועד לבדיקת תקינות נתונים מקלט משתמש

### מודולים/מחלקות שפותחו בפרויקט

1. **User Service**
   - מזהה המחלקה: `user.ts`
   - תפקיד: ניהול פעולות הקשורות למשתמשים
   - תכונות המחלקה:
     - פונקציות לקבלת מידע על משתמשים
     - פונקציות לעדכון פרטי משתמש
     - ניהול הרשאות גישה

2. **Stream Service**
   - מזהה המחלקה: `stream-service.ts`
   - תפקיד: ניהול שידורים חיים
   - תכונות המחלקה:
     - פונקציות לקבלת מידע על שידורים
     - ניהול סטטוס שידור (חי/לא פעיל)
     - הגדרות שידור ומפתחות

3. **AuthenticationHandler**
   - מזהה המחלקה: `auth.ts`
   - תפקיד: טיפול באימות משתמשים
   - תכונות המחלקה:
     - תצורת ספקי אימות (Credentials, Google)
     - ניהול סשנים וטוקנים
     - אימות הרשאות

4. **Follow Service**
   - מזהה המחלקה: `follow-service.ts`
   - תפקיד: ניהול מערכת העוקבים
   - תכונות המחלקה:
     - פונקציות למעקב/הסרת מעקב אחרי משתמשים
     - בדיקת סטטוס מעקב
     - קבלת רשימת עוקבים

5. **Block Service**
   - מזהה המחלקה: `block-service.ts`
   - תפקיד: ניהול חסימות משתמשים
   - תכונות המחלקה:
     - פונקציות לחסימת/ביטול חסימת משתמשים
     - בדיקת סטטוס חסימה
     - קבלת רשימת משתמשים חסומים

## חלק ב - קטעי קוד מרכזיים

### אבטחת אימות משתמשים

```typescript
// Implementation of secure user authentication
export default {
    providers: [
        Google({
            clientId: process.env.GOOGLE_CLIENT_ID,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET,
            async profile(profile) {
                // Generate unique username for Google auth users
                let username = profile.email.split('@')[0];
                while (await getUserByName(username)) {
                    username = "User" + Math.floor(Math.random() * 100000);
                }
                return {
                    id: profile.id,
                    name: username,
                    email: profile.email,
                    image: profile.picture
                }
            }
        }),
        Credentials({
            async authorize(credentials) {
                const validateData = LoginSchema.safeParse(credentials);
                if (!validateData.success) {
                    return null;
                }

                const { name, password } = validateData.data;
                const user = await db.user.findUnique({
                    where: { name }
                });

                if (!user || !user.password || !user.email) {
                    return null;
                }

                // Verify password securely using bcrypt
                const isPasswordValid = await bcrypt.compare(password, user.password);
                if (!isPasswordValid) {
                    return null;
                }

                return {
                    id: user.id + '',
                    email: user.email,
                    name: user.name,
                    image: user.image,
                }
            }
        })
    ],
    // Additional security configuration
    callbacks: {
        async signIn({ user, account}) {
            // Only allow verified email users for credential login
            if (account?.provider !== "credentials") {
                return true;
            }
            const existingUser = await getUserById(user.id ?? "");
            return !!existingUser?.emailVerified;
        }
    }
}
```

### הגנה מפני התקפות על מערכת השידור

```typescript
// Secure streaming key management
export const createIngress = async (ingressType: IngressInput) => {
    const session = await auth();
    const user = session?.user as User;

    // Reset existing ingress to prevent unauthorized access
    await resetIngress(user.id);

    // Set up secure streaming configuration
    const options: CreateIngressOptions = {
        name: user.name,
        roomName: user.id,
        participantName: user.name,
        participantIdentity: user.id,
    }

    // Configure secure streaming protocol
    if (ingressType === IngressInput.WHIP_INPUT) {
        options.enableTranscoding = true;
    } else {
        options.video = {
            source: TrackSource.CAMERA,
            encodingOptions: {
                case: 'preset',
                value: IngressVideoEncodingPreset.H264_1080P_30FPS_3_LAYERS,
            }
        }
        options.audio = {
            source: TrackSource.MICROPHONE,
            encodingOptions: {
                case: 'preset',
                value: IngressAudioEncodingPreset.OPUS_STEREO_96KBPS,
            },
        }
    }

    // Create secure ingress with LiveKit
    const ingress = await ingressClient.createIngress(
        ingressType, options
    );

    if (!ingress || !ingress.url || !ingress.streamKey) {
        throw new Error("Failed to create ingress");
    }

    // Update database with secure streaming keys
    await db.stream.update({
        where: { userId: user.id },
        data: {
            ingressId: ingress.ingressId,
            severUrl: ingress.url,
            streamKey: ingress.streamKey,
        }
    });

    return ingress.ingressId;
}
```

### מערכת ניהול הרשאות וחסימות

```typescript
// Secure viewer token generation with permissions control
export const createViewerToken = async (hostIdentity: string) => {
    let self;

    try {
        // Authenticate user
        const session = await auth()
        if (!session || !session.user || !session.user.id || !session.user.name) {
            // Create guest token with limited permissions
            const id = v4();
            const user = `guest#${Math.floor(Math.random() * 100000)}`;
            self = {id, user};
        } else {
            self = {id: session.user.id, user: session.user.name}
        }
    } catch {
        // Create guest token with limited permissions for error case
        const id = v4();
        const user = `guest#${Math.floor(Math.random() * 100000)}`;
        self = {id, user};
    }

    // Verify host exists
    const host = await getUserById(hostIdentity);
    if (!host) {
        throw new Error("Host not found");
    }

    // Check if user is blocked by host
    const isBlocked = await isBlockedByUser(host.id);
    if (isBlocked) {
        throw new Error("You are blocked by this user");
    }

    // Generate token with appropriate permissions
    const isHost = self.id === host.id;
    const token = new AccessToken(
        process.env.LIVEKIT_API_KEY!,
        process.env.LIVEKIT_API_SECRET!,
        {
            identity: isHost ? `host-${self.id}` : self.id,
            name: self.user,
        }
    );

    // Set appropriate permissions
    token.addGrant({
        room: host.id,
        roomJoin: true,
        canPublish: false,
        canPublishData: true,
    });
    
    return await Promise.resolve(token.toJwt());
}
```

## חלק ג - בדיקות מערכת

### בדיקות שתוכננו בשלב האפיון

1. **בדיקת אימות משתמשים**
   - **מטרת הבדיקה**: לוודא שמערכת האימות מאובטחת ועמידה בפני התקפות
   - **מה בוצע בפועל**: בדיקת תהליך הרשמה, כניסה, אימות אימייל; ניסיונות כניסה חוזרים, בדיקת אכיפת מדיניות סיסמאות
   - **תוצאות הבדיקה**: המערכת זיהתה ומנעה ניסיונות כניסה לא מורשים, אכפה מדיניות סיסמאות, ואימות אימייל פעל כראוי
   - **בעיות שהתגלו ופתרונן**: התגלו מספר חולשות באכיפת חוזק סיסמה ואימות אימייל. בוצע שדרוג בתהליך אימות האימייל והוספת בדיקות נוספות לחוזק סיסמה עם Zod

2. **בדיקת אבטחת מערכת הסטרימינג**
   - **מטרת הבדיקה**: לוודא שערוצי שידור מאובטחים ונגישים רק למשתמשים מורשים
   - **מה בוצע בפועל**: ניסיונות לגשת לשידורים עם מפתחות לא חוקיים, בדיקת הצפנת תקשורת, בדיקת הרשאות צפייה
   - **תוצאות הבדיקה**: המערכת זיהתה ניסיונות לא מורשים לשידור, אכפה הרשאות צפייה, והצפנת התקשורת פעלה כנדרש
   - **בעיות שהתגלו ופתרונן**: התגלתה בעיה במערכת חידוש מפתחות שידור. בוצע תיקון לוגיקת חידוש המפתחות ושיפור מערכת האבטחה

3. **בדיקת מערכת החסימות והעוקבים**
   - **מטרת הבדיקה**: לוודא שמערכת החסימות והעוקבים פועלת כהלכה ומאכיפה הרשאות
   - **מה בוצע בפועל**: בדיקת חסימת משתמשים, הסרת חסימה, מניעת גישה למשתמשים חסומים, בדיקת הרשאות צ'אט
   - **תוצאות הבדיקה**: המערכת אכפה מדיניות חסימות כנדרש, מנעה גישה ממשתמשים חסומים, והרשאות צ'אט פעלו כמצופה
   - **בעיות שהתגלו ופתרונן**: התגלתה בעיה בהתמודדות עם מקרה קצה של משתמש חסום המנסה לגשת לדף הבית. בוצע תיקון לוגיקת הדף הראשי לסינון תוכן ממשתמשים חסומים

### בדיקות נוספות שבוצעו

1. **בדיקת עמידות מערכת הצ'אט**
   - **מטרת הבדיקה**: לוודא שמערכת הצ'אט עמידה בפני ניסיונות ספאם והצפה
   - **מה בוצע בפועל**: בדיקת שליחת הודעות מרובות, בדיקת הודעות ארוכות, בדיקת תווים מיוחדים
   - **תוצאות הבדיקה**: המערכת טיפלה כראוי בהודעות תקינות אך נדרש שיפור בניהול הודעות רבות בו-זמנית
   - **בעיות שהתגלו ופתרונן**: התגלו בעיות ביצועים בעומס גבוה. בוצע שיפור המתווך (middleware) לניהול הודעות, יישום הגבלת קצב (rate limiting), והוספת מטמון (cache) לשיפור ביצועים

2. **בדיקת אבטחה מקיפה**
   - **מטרת הבדיקה**: לזהות חולשות אבטחה אפשריות במערכת
   - **מה בוצע בפועל**: סריקת חולשות באמצעות כלי OWASP ZAP, בדיקות XSS, SQL Injection, CSRF
   - **תוצאות הבדיקה**: זוהו מספר חולשות קלות בטיפול בקלט משתמש ובהגנת CSRF
   - **בעיות שהתגלו ופתרונן**: שופרה סניטציה של קלט משתמש, הוספת הגנת CSRF חזקה יותר, שיפור הגדרות תגובות HTTP

# מדריך למשתמש

## פירוט כלל קבצי המערכת – עץ קבצים

```
/
├── actions/                  # פעולות בצד השרת
│   ├── auth/                 # פעולות אימות
│   ├── block.ts              # פעולות חסימת משתמשים
│   ├── follow.ts             # פעולות מעקב אחרי משתמשים
│   ├── ingress.ts            # פעולות ניהול שידור
│   └── stream.ts             # פעולות ניהול ערוץ
├── app/                      # מבנה האפליקציה
│   ├── (auth)/               # דפי אימות
│   ├── (browse)/             # דפי צפייה
│   ├── (dashboard)/          # דפי ניהול למשתמש
│   └── api/                  # נקודות קצה API
├── components/               # רכיבי UI
│   ├── ui/                   # רכיבי UI בסיסיים
│   ├── stream-player/        # רכיבי נגן שידור
│   └── auth/                 # רכיבי אימות
├── data/                     # שירותי גישה לנתונים
├── lib/                      # ספריות ושירותים
│   ├── db.ts                 # חיבור למסד נתונים
│   ├── follow-service.ts     # שירות מעקב
│   ├── block-service.ts      # שירות חסימה
│   └── stream-service.ts     # שירות שידור
├── public/                   # קבצים סטטיים
│   └── logo.svg              # לוגו האפליקציה
├── prisma/                   # הגדרות Prisma ORM
│   └── schema.prisma         # סכמת מסד הנתונים
└── store/                    # ניהול מצב כללי
```

## התקנת המערכת

### פירוט הסביבה הנדרשת
- **Node.js** גרסה 18 ומעלה
- **MySQL** גרסה 8 ומעלה
- **דפדפן מודרני** (Chrome, Firefox, Edge, Safari)
- **חיבור אינטרנט** מהיר (לפחות 10Mbps לצפייה, 5Mbps לשידור)

### פירוט הכלים הנדרשים
- **Git** לשכפול המאגר
- **npm** או **yarn** לניהול חבילות
- **תוכנת שידור** כגון OBS Studio (למשדרים בלבד)

### מיקומי קבצים
- **קבצי קונפיגורציה**: בספריית `/`
- **קבצי סביבה**: `.env.local`
- **מסד נתונים**: מאוחסן בשרת MySQL נפרד

### נתונים התחלתיים
- **משתמש אדמין לדוגמה**: `admin`
- **סיסמה לדוגמה**: `adminPassword123`

### רשת
- **פורט ברירת מחדל**: 3000
- **פרוטוקול**: HTTP/HTTPS

### ארכיטקטורה מינימלית נדרשת
- **מעבד**: Dual Core 2GHz+
- **זיכרון**: 4GB RAM מינימום
- **אחסון**: 10GB מינימום
- **רוחב פס**: 10Mbps מינימום

## משתמשי המערכת

### משתמש קצה (צופה)

#### אופן הפעלת המערכת
1. היכנס לכתובת האתר בדפדפן
2. לחץ על "התחבר" בפינה העליונה
3. הזן פרטי כניסה או הירשם באמצעות חשבון Google
4. גלוש בדף הבית לגילוי שידורים חיים
5. לחץ על שידור כדי לצפות בו
6. השתמש בצ'אט בצד ימין כדי לתקשר עם המשדר ומשתמשים אחרים
7. לחץ על "עקוב" כדי לעקוב אחר ערוצים מועדפים
8. השתמש בסרגל החיפוש למעלה כדי למצוא ערוצים ספציפיים

#### צילומי מסך רלוונטיים
![מסך ראשי לצופה]
![מסך צפייה בשידור]
![מסך חיפוש]

### מנהל מערכת (סטרימר)

#### אופן הפעלת המערכת
1. היכנס לכתובת האתר בדפדפן
2. לחץ על "התחבר" והזן פרטי כניסה
3. לחץ על אייקון המשתמש ובחר "לוח מחוונים"
4. בלוח המחוונים, יש גישה למספר מסכים:
   - **שידור**: צפייה מקדימה בערוץ שלך
   - **מפתחות**: הצגת מפתחות שידור וכתובות שרת
   - **צ'אט**: הגדרות מערכת הצ'אט (הגבלות, השהייה)
   - **קהילה**: ניהול משתמשים חסומים
5. להתחלת שידור:
   - העתק את כתובת השרת ומפתח השידור ממסך "מפתחות"
   - הגדר את תוכנת השידור (כגון OBS) עם פרטים אלה
   - התחל שידור בתוכנת השידור
6. ניהול פרופיל:
   - שנה את כותרת השידור ותמונה ממוזערת במסך "שידור"
   - הגדר את ביוגרפיית הערוץ והעלה תמונת פרופיל
   - הגדר העדפות צ'אט במסך "צ'אט"

#### צילומי מסך רלוונטיים
![לוח מחוונים סטרימר]
![מסך מפתחות שידור]
![מסך הגדרות צ'אט]
![מסך ניהול קהילה]

# סיכום אישי / רפלקציה

## תיאור תהליך העבודה

תהליך העבודה על פרויקט ROIM היה מסע מאתגר ומעשיר. התחלתי עם מחקר מעמיק של פלטפורמות סטרימינג קיימות ואספתי דרישות מקיפות. שלב התכנון כלל בחירת הטכנולוגיות המתאימות ביותר, כאשר בחרתי ב-Next.js כמסגרת העבודה העיקרית בשל היכולות המתקדמות שלה בפיתוח אפליקציות ווב מהירות ומאובטחות.

האתגר העיקרי היה יישום מערכת הסטרימינג בזמן אמת. לאחר ניסיונות עם מספר פתרונות, בחרתי ב-LiveKit בשל היכולות והביצועים המרשימים שלו. תהליך האינטגרציה של LiveKit היה מורכב, אך הצלחתי להתגבר על הקשיים באמצעות לימוד עצמי וניסוי וטעייה.

הייתי גאה במיוחד ביישום מערכת האבטחה המקיפה. השקעתי זמן רב בלמידת פרקטיקות אבטחה מודרניות והטמעתן בפרויקט, כולל הגנה מפני התקפות נפוצות, אימות משתמשים מאובטח, והצפנת מידע רגיש.

## תהליך למידה

במהלך הפרויקט, למדתי מספר טכנולוגיות ומושגים חדשים:
- **WebRTC** ופרוטוקולי סטרימינג - למדתי כיצד לעבוד עם טכנולוגיות שידור וידאו בזמן אמת
- **NextAuth** - העמקתי בלימוד של מערכות אימות מתקדמות ואבטחתן
- **Prisma ORM** - למדתי כיצד לעבוד עם מסדי נתונים בצורה מאובטחת יותר
- **TypeScript** - שיפרתי את כישורי התכנות עם הקפדה על טיפוסים ואיכות קוד
- **LiveKit SDK** - למדתי להשתמש בספריית סטרימינג מורכבת

המעבר מתכנות בסיסי לפיתוח אפליקציה מלאה ומורכבת היה אתגר משמעותי, אך ההתמדה והסקרנות הובילו לתוצאות מרשימות.

## כלים לעתיד

הפרויקט העניק לי כלים טכניים ומיומנויות רבות שאקח להמשך:
- יכולת פיתוח מערכות אבטחה מתקדמות
- ידע בפיתוח אפליקציות בזמן אמת
- מיומנויות בעבודה עם מסדי נתונים מורכבים
- הבנה מעמיקה של ארכיטקטורות תוכנה מודרניות
- מיומנויות פתרון בעיות ודיבאגינג

## תובנות מהתהליך

העבודה על הפרויקט לימדה אותי רבות על פיתוח תוכנה בעולם האמיתי. למדתי שתכנון מדויק הוא קריטי, אך גם יכולת הסתגלות והתמודדות עם שינויים חשובה לא פחות. עבדתי עם מספר מקורות מידע מקוונים ונעזרתי בקהילות מפתחים, מה שהדגיש את חשיבות שיתוף המידע בעולם התוכנה.

התייעצתי עם מנחה הפרויקט בנקודות מפתח, במיוחד בנושאי אבטחת סייבר, והעזרה שלו הייתה משמעותית בשיפור המערכת. למדתי גם על חשיבות הבדיקות המקיפות והמתמשכות לאורך כל תהליך הפיתוח.

## בחינה רטרוספקטיבית

בראייה לאחור, הייתי בוחר להקדיש יותר זמן לתכנון הארכיטקטורה בתחילת הפרויקט. מספר החלטות ארכיטקטוניות הובילו לעבודה כפולה בשלבים מאוחרים יותר. הייתי גם מיישם גישה מודולרית יותר מההתחלה, מה שהיה מקל על תחזוקת הקוד ושדרוגים עתידיים.

הבחירה ב-Next.js הייתה נכונה, אך הייתי שוקל להשתמש בארכיטקטורת מיקרו-שירותים (microservices) עבור חלקים מסוימים של המערכת, במיוחד עבור מערכת הסטרימינג והצ'אט, כדי לשפר את יכולת ההרחבה (scalability).

## שיפורים עתידיים

אילו היו ברשותי משאבים נוספים, הייתי משפר את הפרויקט במספר דרכים:
- הוספת מערכת תשלומים ומנויים לתמיכה בסטרימרים
- פיתוח אפליקציות מובייל ילידות לחוויית משתמש משופרת
- הוספת יכולות ניתוח נתונים ואנליטיקה למשדרים
- שיפור יכולות הקהילה עם פורומים ותוכן משתמשים
- יישום טכנולוגיות AI למודרציה אוטומטית של תוכן

## סיכום

פרויקט ROIM היה אתגר משמעותי שדרש ממני לשלב ידע ממגוון תחומים בהנדסת תוכנה ואבטחת סייבר. ההתמודדות עם האתגרים, הלמידה המתמדת והיישום של טכנולוגיות מתקדמות הובילו ליצירת מערכת שאני גאה בה. הפרויקט לא רק שיפר את הידע הטכני שלי, אלא גם את היכולת לנהל פרויקט מורכב מהתכנון ועד היישום. אני מאמין שהכלים והניסיון שצברתי יהיו בעלי ערך רב בהמשך הדרך.

# ביבליוגרפיה

1. Next.js Documentation. (2025). "Authentication". Retrieved from https://nextjs.org/docs/authentication

2. LiveKit Documentation. (2024). "Server SDK". Retrieved from https://docs.livekit.io/server-sdk/

3. OWASP. (2024). "OWASP Top Ten Web Application Security Risks". Retrieved from https://owasp.org/www-project-top-ten/

4. Sullivan, J. (2023). *Modern Web Application Security*. O'Reilly Media.

5. Williams, M. (2024). "Secure Authentication Practices for Web Applications". Journal of Cybersecurity, 12(3), 45-62.

6. Prisma Documentation. (2025). "Data Security". Retrieved from https://www.prisma.io/docs/concepts/data-security

7. Cohen, D. (2024). *Streaming Technologies: Implementation and Security*. Tech Publishing.

8. TypeScript Documentation. (2024). "Security with TypeScript". Retrieved from https://www.typescriptlang.org/docs/handbook/security.html

# נספחים

## נספח א': יישום אלגוריתם אימות משתמש

```typescript
// auth.ts - User authentication implementation
import { PrismaAdapter } from "@auth/prisma-adapter";
import { db } from "@/lib/db";
import authConfig from "./auth.config";
import {getUserById} from "@/data/user";
import {getAccountByUserId} from "@/data/account";

export const {
    handlers: { GET, POST },
    auth,
    signIn,
    signOut
} = NextAuth({
    callbacks: {
        async signIn({ user, account}) {
            // For OAuth providers, allow sign in directly
            if (account?.provider !== "credentials") {
                return true;
            }
            // For credentials, verify email before allowing sign in
            const existingUser = await getUserById(user.id ?? "");
            return !!existingUser?.emailVerified;
        },
        async session({ token, session }) {
            // Add user ID to session for authorization checks
            return {
                ...session,
                user: {
                    ...session.user,
                    id: token.sub
                }
            }
        },
        async jwt({ token }) {
            // Enhance JWT with additional user data
            if (!token.sub) return token;
            const user = await getUserById(token.sub);
            if (!user) return token;
            const account = await getAccountByUserId(user.id);
            token.isOauth = !!account;
            token.name = user.name;
            token.email = user.email;
            token.image = user.image;
            return token;
        },
    },
    adapter: PrismaAdapter(db),
    session: {
        strategy: "jwt",
    },
    ...authConfig,
});
```

## נספח ב': מודל מסד הנתונים

```prisma
// schema.prisma - Database schema definition
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(name: "Accounts", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model VerificationToken {
  id      String   @id @default(uuid())
  email   String
  token   String
  expires DateTime

  @@unique([email, token])
}

model ResetToken {
  id      String   @id @default(uuid())
  email   String
  token   String
  expires DateTime

  @@unique([email, token])
}

model User {
  id            String    @id @default(uuid())
  name          String    @unique @default(uuid())
  email         String?   @unique
  emailVerified DateTime?
  password      String?
  image         String    @default("/default.png")
  bio           String?   @db.Text

  accounts Account[] @relation("Accounts")

  following  Follow[] @relation("Following")
  followedBy Follow[] @relation("FollowedBy")

  blocking  Block[] @relation("Blocking")
  blockedBy Block[] @relation("Blocked")

  stream Stream?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Stream {
  id           String  @id @default(uuid())
  name         String  @db.Text
  thumbnailUrl String? @db.Text

  ingressId String? @unique
  severUrl  String? @db.Text
  streamKey String? @db.Text

  isLive              Boolean @default(false)
  isChatEnabled       Boolean @default(true)
  isChatDelayed       Boolean @default(false)
  isChatFollowersOnly Boolean @default(false)

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([ingressId])
  @@fulltext([name])
}

model Follow {
  id          String @id @default(uuid())
  follower    User   @relation(name: "Following", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String
  following   User   @relation(name: "FollowedBy", fields: [followingId], references: [id], onDelete: Cascade)
  followingId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Block {
  id        String @id @default(uuid())
  blocker   User   @relation(name: "Blocking", fields: [blockerId], references: [id], onDelete: Cascade)
  blockerId String
  blocked   User   @relation(name: "Blocked", fields: [blockedId], references: [id], onDelete: Cascade)
  blockedId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}
```

## נספח ג': יישום מערכת ניטור שידור

```typescript
// route.ts - Stream monitoring webhook handler
import { WebhookReceiver } from "livekit-server-sdk";
import { db } from "@/lib/db";

const receiver = new WebhookReceiver(
    process.env.LIVEKIT_API_KEY!,
    process.env.LIVEKIT_API_SECRET!
);

export async function POST(req: Request) {
    const body = await req.text();
    console.log("Raw body:", body);
    const authorization = req.headers.get("Authorization");

    if (!authorization) {
        return new Response("Unauthorized", { status: 400 });
    }

    // Verify the webhook request is authentic
    const event = await receiver.receive(body, authorization);

    // Handle stream start event
    if (event.event === "ingress_started") {
        await db.stream.update({
            where: {
                ingressId: event.ingressInfo?.ingressId,
            },
            data: {
                isLive: true,
            },
        });
    }

    // Handle stream end event
    if (event.event === "ingress_ended") {
        await db.stream.update({
            where: {
                ingressId: event.ingressInfo?.ingressId,
            },
            data: {
                isLive: false,
            },
        });
    }

    return new Response("OK", { status: 200 });
}
```

## נספח ד': מערכת צ'אט בזמן אמת

```typescript
// chat.tsx - Real-time chat component implementation
"use client";

import {useMediaQuery} from "usehooks-ts";
import {ChatVeriant, useChatSidebar} from "@/store/use-chat-sidebar";
import {useChat, useConnectionState, useRemoteParticipant} from "@livekit/components-react";
import {ConnectionState} from "livekit-client";
import {useEffect, useMemo, useState} from "react";
import {ChatHeader} from "@/components/stream-player/chat-header";
import {ChatForm} from "@/components/stream-player/chat-form";
import {ChatList} from "@/components/stream-player/chat-list";
import {ChatCommunity} from "@/components/stream-player/chat-community";

interface ChatProps {
    hostName: string;
    hostIdentity: string;
    viewerName: string;
    isFollowing: boolean;
    isChatEnabled: boolean;
    isChatDelayed: boolean;
    isChatFollowersOnly: boolean;
}

export const Chat = ({
    hostName,
    hostIdentity,
    viewerName,
    isFollowing,
    isChatEnabled,
    isChatDelayed,
    isChatFollowersOnly} : ChatProps) => {
    const matches = useMediaQuery("(max-width: 1024px)");
    const {variant, onExpand} = useChatSidebar((state) => state)
    const connectionState = useConnectionState();
    const participant = useRemoteParticipant(hostIdentity);

    // Determine if stream is online
    const isOnline = participant && connectionState === ConnectionState.Connected;

    // Hide chat if disabled or stream is offline
    const isHidden = !isChatEnabled || !isOnline;

    const [value, setValue] = useState("");
    const { chatMessages: messages, send } = useChat();

    // Expand chat sidebar on mobile
    useEffect(() => {
        if (matches) {
            onExpand();
        }
    }, [matches, onExpand]);

    // Sort messages in reverse chronological order
    const reversedMessages = useMemo(() => {
        return messages.sort((a, b) => b.timestamp - a.timestamp);
    }, [messages]);

    // Handle message submission
    const onSubmit = () => {
        if (!send) return;
        send(value);
        setValue("");
    }

    const onChange = (value: string) => {
        setValue(value);
    }

    return (
        <div className="flex flex-col border-l border-b border-background pt-0 h-[calc(100vh-80px)] bg-[#1e1e1e] border-[#2D2E35]">
            <ChatHeader />
            {variant === ChatVeriant.CHAT && (
                <>
                    <ChatList
                        messages={reversedMessages}
                        isHidden={isHidden}
                    />
                    <ChatForm
                        onSubmit={onSubmit}
                        value={value}
                        onChange={onChange}
                        isHidden={isHidden}
                        isFollowersOnly={isChatFollowersOnly}
                        isDelayed={isChatDelayed}
                        isFollowing={isFollowing}
                    />
                </>
            )}
            {variant === ChatVeriant.COMMUNITY && (
                <ChatCommunity
                    viewerName={viewerName}
                    hostName={hostName}
                    isHidden={isHidden}
                />
            )}
        </div>
    )
}
```